module P = Lwt;
module S = Lwt_stream;

module Main: {
  type name = string;
  type processor =
    | Fabricator(string)
    | Refabricator(string)
    | Factory(string);
  type processors = list(processor);
  type t('content) =
    pri {
      name,
      content: 'content,
      processedBy: processors,
    };
  type fabric('content) = Lwt_stream.t(t('content));

  type refabricator('input, 'output) = fabric('input) => fabric('output);
  type factory('content) =
    fabric('content) => Lwt.t(list(result(t('content), list(string))));

  type markdown = string;

  let fabricate: (~name: name, ~fabricator: string, 'content) => t('content);
  let refabricate:
    (~refabricator: string, 'input => 'output, t('input)) => t('output);
} = {
  //----------TYPES----------
  type name = string;
  type processor =
    | Fabricator(string)
    | Refabricator(string)
    | Factory(string);
  type processors = list(processor);
  type t('content) = {
    name,
    content: 'content,
    processedBy: processors,
  };
  type fabric('content) = Lwt_stream.t(t('content));

  type refabricator('input, 'output) = fabric('input) => fabric('output);
  type factory('content) =
    fabric('content) => Lwt.t(list(result(t('content), list(string))));
  //-------------------------

  type markdown = string;

  let fabricate = (~name, ~fabricator, content) => {
    name,
    content,
    processedBy: [Fabricator(fabricator)],
  };

  let refabricate = (~refabricator, process, t) => {
    name: t.name,
    content: t.content |> process,
    processedBy: [Refabricator(refabricator), ...t.processedBy],
  };
};

module Fabricators = {
  let localPath: (~filterExtension: string=?, string) => Main.fabric(string) =
    (~filterExtension=?, path) =>
      Lwt_unix.files_of_directory(path)
      |> S.filter(fileName =>
           !(fileName |> Filename.concat(path) |> Sys.is_directory)
         )
      // TODO: Instead of filtering out directories, recursively read them in
      //       and pass them down the stream
      |> S.filter_map_s(fileName => {
           let filePath = fileName |> Filename.concat(path);
           switch (filterExtension, Filename.extension(fileName)) {
           | (None, _) => P.return_some(filePath)

           | (Some(wanted), found) when wanted == found =>
             P.return_some(filePath)
           | (_, _) => P.return_none
           };
         })
      |> S.map_s(fileName => {
           Lwt_io.open_file(~mode=Input, fileName)
           |> P.bind(_, Lwt_io.read)
           |> P.map(Main.fabricate(~name=fileName, ~fabricator="localPath"))
         });
};

module Refabricators = {
  let markdown: Main.refabricator(string, Main.markdown) =
    stream => {
      let string2html = md => md |> Omd.of_string |> Omd.to_html;
      stream
      |> Lwt_stream.map(
           Main.refabricate(~refabricator="markdown", string2html),
         );
    };

  let between:
    (~before: string, ~after: string) => Main.refabricator(string, string) =
    (~before, ~after, stream) =>
      stream
      |> S.map(
           Main.refabricate(~refabricator="between", content =>
             before ++ content ++ after
           ),
         );
};

module Factories = {
  let log: Main.factory(string) =
    stream => {
      stream
      |> S.map_s(x => {Lwt_io.printl("\n\nLOG:\n" ++ Main.(x.content)) |> Lwt.map(_=> Ok(x))})
      |> S.to_list
    };
};

let main =
  "./pages"
  |> Fabricators.localPath
  |> Refabricators.markdown
  |> Refabricators.between(
       ~before=
         "<html><head><title>Site generated with Refabricator</title></head><body><main>\n",
       ~after=
         "\n"
         ++ {|</main><footer>This site was generated by <a href="https://github.com/woeps/Refabricator">Refabricator</a>!</footer></body></html>|},
     )
  |> Factories.log;

Lwt_main.run(main);

/*
 let (stream, push) = S.create();

 let main =
   stream
   |> S.map_s(x => Lwt_io.printl(string_of_float(x)) |> P.map(_ => x))
   |> S.map_s(x => Lwt_unix.sleep(10. -. x) |> P.map(_ => x))
   |> S.map_s(x => x |> string_of_float |> Lwt_io.printl |> P.map(_ => x))
   |> S.to_list
   |> P.map(l => Console.log(l));

 P.async(() => {
   [4., 2., 1., 0.]
   |> List.map(x => Lwt_unix.sleep(x) |> P.map(_ => push(Some(x))))
   |> P.all
   |> P.map(_ => push(None))
 });

 Lwt_main.run(main);
 */
